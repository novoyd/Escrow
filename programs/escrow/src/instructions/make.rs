use anchor_lang::prelude::*;
use anchor_spl::{
    self, 
    token_interface::{TransferChecked, Mint, TokenAccount, TokenInterface, transfer_checked}, 
    associated_token::Associated_token}; 
//derive accounts is applied to struct to specify accts that must be provided
//when an instruction is evoked 
#[derive(Accounts)]

#[instruction(seed: u64)]
pub struct Make<'info> {
    //the maker acct has to be mutable here cause its paying for account creations(changing its lamport bal)
    #[account(mut)]
    pub maker: Signer<'info>; 
    pub mint_a: Interface<'info, Mint>;
    pub mint_b: Interface<'info, Mint>;
    #[account(
        // we need it mut here because we will be debiting tokens from this acct
        mut, 
        Associated_token::mint = mint_a,
        //
        Associated_token:authority = maker, 
    )]
    pub maker_ata_a; InterfaceAccount<'info, TokenAccount>,

    #[account(
        //init is for allocate acct on chain 
        init,
        // Payer is person who pays fees (remt+creation fee)
        payer = maker, 
        //Seeds define PDA address b"escrow is byte literal (static seed) ,as_ref converts to byte form,
        //le_bytes is little endian( least signifcant bytes at lowest memory address )
        seeds = [b"escrow",maker.key().as_ref(), seed.to_le_bytes().as_ref()],
        //self explanatory 
        bump, 
        space = 8 + Escrow::INIT_SPACE,
    )]
    // Escrow acct is the Anchor Escrow module
    pub escrow: Account<'info, Escrow>
    //vault is for storing tokens and escrow is data acct storing custom state
    #[account(
        init, 
        payer = maker,
        
        associated_token::mint = mint_a,
        associated_token::authority = escrow, 
    )]
    // vault must comply with spl token standard, escrow is custom struct
    pub vault: InterfaceAccount<'info, TokenAccount>
    //needed for creating associated token accts
    pub associated token_program: Program<'info, Associated_token>,
    // SPL token or token22 program we will cpi into
    pub token_program: Interface<'info, TokenInterface>,
    //system_program by default has interface defined for it over here 
    //and is required for system level instructions
    pub system_program: Program<'info, System>

}
// lifetime implemented in the generic parameter (impl) and type (Make)
impl<'info> Make <'info> {
    // mut self for mutating the field inside self.escrow
    // &MakeBumps is automatically generated by anchor when using pdas with bump
    pub fn init_escrow(&mut self, seed: u64, receive:u64, bump: &MakeBumps) -> Result<()> {
        // set inner overwrites Escrow acct data with new vals
        self.escrow.set_inner(Escrow {
            seed, 
            maker: self.maker.key(), 
            mint_a : sef.mint_a.key(),
            mint_b : self.mint_b.key(),
            receive,
            bump: bumps.escrow

        });
        // always return in anchor instruction if no error
        Ok(());

    }

    pub fn deposit(&mut self, deposit: u64) {
        //so in this cpi we are calling SPL token programs  
        let cpi_program = self.token_program.to_account_info();
        // Transfer checked seems to be a struct for defining accts to pass to transfer_checked instruction 
        let cpi_account = TransferChecked {
            mint: self.mint_a.to_account_info(),
            //from and to self explanatory
            from: self.maker.to_account_info(),
            to: self.vault.to_account_info(), 
            // self explanatory to_account_info over here tho
            authority: self.maker.to_account_info(),

        };
        //  the cpi_context over here bundles the program id and relvant acct structs
        let cpi_ctx = CpiContext::new(cpi_program, cpi_account);
        transfer_checked(cpi_ctx, deposit, self.mint_a.decimals);
    }
}
